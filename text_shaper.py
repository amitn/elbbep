from itertools import chain
import subprocess
import json
import struct
# This file generates the code that drives the Arabic text shaper SM.
# It also generates the glyph-codepoint mapping used to produce the Arabic fonts.
# It requires the hb-shape CLI tool.

font_path = "/Volumes/MacintoshHD/Users/collinfair/Pebble/quran/resources/fonts/me_quran.ttf"
font_size = 22

def generate_forms():
    alphabet = "غظضذخثتشرقصفعسنملكيطحزوهدجبا"
    kashida = "ـ"
    missing_glyph = None

    def shape_text(txt):
        process = subprocess.Popen(['hb-shape', font_path, '--output-format=json', '--no-glyph-names'], stdout=subprocess.PIPE, stdin=subprocess.PIPE)
        out, err = process.communicate(txt.encode("utf-8"))
        glyphs = list(json.loads(out.decode("utf-8")))
        # Check for missing glyphs
        missing_chars = set()
        for glyph in glyphs:
            if glyph["g"] == missing_glyph:
                missing_char = txt[glyph["cl"]:glyph["cl"]+1]
                missing_chars.add(missing_char)

        if missing_chars:
            raise Exception("The following characters are missing from the font: %s" % missing_chars)
        return glyphs

    missing_glyph = shape_text("ᓄ")[0]["g"]
    kashida_glyph = shape_text(kashida)[0]["g"]

    forms = {}
    for ch in alphabet:
        ch_comps = [ch, ch + kashida, kashida + ch + kashida, kashida + ch]
        ch_forms = []
        for ch_comp in ch_comps:
            shaped = shape_text(ch_comp)
            target_glyphs = [x for x in shaped if x["g"] != kashida_glyph]
            assert len(target_glyphs) == 1
            target_glyph = target_glyphs[0]["g"]
            ch_forms.append(target_glyph)
        forms[ch] = ch_forms
    return forms

def pack_lut(forms):
    # LUT is simply repeated <true codept, isolated codept, initial, medial, final>
    # The runtime automatically detects characters like alef that restart the SM.
    # We recycle some of the dustier blocks in the 2-byte UTF8 range.
    available_codepts = chain(range(0x700, 0x750), range(0x780, 0x7FF + 1))
    selected_glyphs = {}
    lut_data = bytes()
    for ch in sorted(list(forms.keys())):
        ch_forms = forms[ch]
        line_parts = [ord(ch)]
        for glyph in ch_forms:
            if glyph not in selected_glyphs:
                selected_glyphs[glyph] = next(available_codepts)
            line_parts.append(selected_glyphs[glyph])
        lut_data += struct.pack("<HHHHH", *line_parts)
    return lut_data, selected_glyphs

def build_font(selected_glyphs):
    # Despite having been written about 5 minutes apart, fontgen's map option expects a different dict than we have on hand.
    selected_codepts = {v: k for k, v in selected_glyphs.items()}
    json.dump(selected_codepts, open("glyphs-arabic.json", "w"))
    subprocess.check_call(["python", "pebble-sdk/fontgen.py", "pfo", str(font_size), "--map", "glyphs-arabic.json", font_path, "arabic.pfo"])

def write_lut(lut_data):
    lut_h = open("runtime/text_shaper_lut.h", "w")
    lut_h.write("#include \"pebble.h\"\n// THIS FILE IS AUTOMATICALLY GENERATED\n\n")
    lut_c = open("runtime/text_shaper_lut.c", "w")
    lut_c.write("#include \"text_shaper_lut.h\"\n// THIS FILE IS AUTOMATICALLY GENERATED\n\n")
    def write_array(datatype, name, elements):
        lut_h.write("extern %s %s[];\n" % (datatype, name))
        lut_h.write("#define %s_SIZE %d\n" % (name, len(elements)))
        lut_c.write("%s %s[] = {%s};\n" % (datatype, name, ", ".join("0x%x" % x for x in elements)))
    # This isn't a real lookup table, since you can't index directly into it.
    # For shame - but doing so would double the memory footprint in exchange for saving a relatively small loop?
    write_array("const uint8_t", "ARABIC_SHAPER_LUT", lut_data)

# Get the glyph indices corresponding to the forms of the various letters.
character_forms = generate_forms()
# Build the LUT
# This also assigns codepoints to the glyph within the defined ranges
lut_data, selected_glyphs = pack_lut(character_forms)
print(character_forms)
# Write the LUT
write_lut(lut_data)
# Build the PFO
build_font(selected_glyphs)
